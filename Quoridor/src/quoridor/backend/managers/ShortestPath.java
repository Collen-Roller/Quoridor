package quoridor.backend.managers;

import java.awt.Point;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Set;

import quoridor.backend.containers.Position;
import quoridor.backend.pieces.Pawn;
import quoridor.backend.pieces.Walls;

/**
 * @author Team 4 Men And A Cripple
 * @version 2014-05-04
 *
 * This class generates the shortest path between a pawn and a destination. The
 * destination can either be a single position or a row or column.
 */
public class ShortestPath {

	/**
	 * The path generated by this algorithm.
	 */
	private ArrayList<Position> path;
	
	/**
	 * The pawn that this shortest path belongs to.
	 */
	private Pawn pawn;

	/**
	 * Whether the destination of the path is being determined by a position or
	 * by the pawns win condition.
	 */
	private boolean byPos;

	/**
	 * Constructs a new shortest path from a given pawn, position, set of walls,
	 * and list of pawns.
	 * 
	 * @param pa The pawn to generate this path around.
	 * @param po The destination of this path, null if path is determined by
	 *           the pawn's win condition.
	 * 
	 * @param w The current wall configuration to determine this path around.
	 * @param pawns The pawns currently existing in the game state.
	 */
	public ShortestPath(Pawn pa, Position po, Walls w, ArrayList<Pawn> pawns) {
		path = null;
		pawn = pa;
		byPos = po != null;
		Set<Position> possibleMoves = pa.calcMoves(w, pawns);
		ArrayList<ArrayList<Position>> paths
		    = new ArrayList<ArrayList<Position>>();
		for(Position p : possibleMoves)
			paths.add(genPath(p, po, w));
		Point p = new Point(0, 10000);
		for(int i = 0; i < paths.size(); i++)
			if(paths.get(i) != null && paths.get(i).size() < p.y)
				p = new Point(i, paths.get(i).size());
		if(p.y < 10000)
			path = paths.get(p.x);
	}

	/**
	 * Generates the shortest path.
	 * 
	 * @param p The starting position for generating this path.
	 * @param po The destination position for generating this path.
	 * @param w The walls to consider during path-finding.
	 * @return The list of positions that make up this path.
	 */
	private ArrayList<Position> genPath(Position p, Position po, Walls w) {
		Node<Position> current = new Node<Position>(p, null);
		if(byPos) {
		    if(current.getData().equals(po))
		        return current.getPathToRoot();
		} else
		    if(current.getData().toString().matches(pawn.getWinCondition()))
		        return current.getPathToRoot();
		Queue<Node<Position>> nodes = new LinkedList<Node<Position>>();
		nodes.add(current);
		do {
			current = nodes.remove();
			current.addChild(new Position(current.getData().x + 1,
			        current.getData().y));
	        current.addChild(new Position(current.getData().x,
	                current.getData().y + 1));
	        current.addChild(new Position(current.getData().x - 1,
	                current.getData().y));
	        current.addChild(new Position(current.getData().x,
	                current.getData().y - 1));
	        Iterator<Node<Position>> itr = current.getChildren().iterator();
	        while(itr.hasNext()) {
	            Node<Position> pos = itr.next();
	            if(pos.getData().x < 0 || pos.getData().y < 0
	                    || pos.getData().x > 8 || pos.getData().y > 8
	                    || w.isBlocked(pos.getData(), current.getData()))
	                itr.remove();
	        }
	        nodes.addAll(current.getChildren());
	        for(Node<Position> pos : current.getChildren())
	            if(byPos) {
	                if(pos.getData().equals(po))
	                    return pos.getPathToRoot();
	            } else
	                if(pos.getData().toString().matches(pawn.getWinCondition()))
	                    return pos.getPathToRoot();
			} while(!nodes.isEmpty());
		return null;
	}
	
	/**
	 * Gets the path generated by this algorithm.
	 * 
	 * @return The path generated by this algorithm.
	 */
	public ArrayList<Position> getPath() {
		return path;
	}

}

/**
 * @author Team 4 Men And A Cripple
 *
 * This class represents a single node in a tree used for path-finding.
 *
 * @param <T> The data type stored in a given node.
 */
class Node<T> {

	/**
	 * The data this node represents. For typical path-finding the data field
	 * would represent a position.
	 */
	private T data;
	
	/**
	 * The parent node of this node.
	 */
	private Node<T> parent;
	
	/**
	 * All nodes considered to be children of this node.
	 */
	private ArrayList<Node<T>> children;

	/**
	 * Constructs a new node from a given datum and parent node. Root node
	 * receives null as its parent node.
	 * 
	 * @param data The data this node represents.
	 * @param parent The parent of this node.
	 */
	public Node(T data, Node<T> parent) {
		this.data = data;
		this.parent = parent;
		children = new ArrayList<Node<T>>();
	}

	/**
	 * Adds a new child to this node.
	 * 
	 * @param child The child node to be added.
	 */
	public void addChild(T child) {
		if(!contains(new Node<T>(child, null))) {
			children.add(new Node<T>(child, this));
		}
	}

	/**
	 * Removes a child from the children of this node.
	 * 
	 * @param child The child node to be removed.
	 */
	public void removeChild(Node<T> child) {
		children.remove(child);
	}

	/**
	 * Gets the parent of this node.
	 * 
	 * @return The parent of this node.
	 */
	public Node<T> getParent() {
		return parent;
	}

	/**
	 * Gets the list of children of this node.
	 * 
	 * @return The list of children of this node.
	 */
	public ArrayList<Node<T>> getChildren() {
		return children;
	}

	/**
	 * Returns the data stored in this node.
	 * 
	 * @return The data stored in this node.
	 */
	public T getData() {
		return data;
	}

	/**
	 * Returns a list of each direct ancestor of this node to the root node.
	 * This list of nodes is the path generated by the path-finding algorithm.
	 * 
	 * @return The list of each direct ancestor of this node to the root node.
	 */
	public ArrayList<T> getPathToRoot() {
		Node<T> current = this;
		ArrayList<T> path = new ArrayList<T>();
		while(current != null) {
			path.add(current.getData());
			current = current.getParent();
		}
		Collections.reverse(path);
		return path;
	}

	/* (non-Javadoc)
	 * @see java.lang.Object#equals(java.lang.Object)
	 */
	@SuppressWarnings("unchecked")
    public boolean equals(Object o) {
		if(!o.getClass().equals(this.getClass()))
			return false;
		return data.equals(((Node<T>) o).data);
	}

	/**
	 * Determines if the given node is a parent in the tree this node belongs
	 *            to. For a node to be considered contained it must exist
	 *            higher in the hierarchy of the tree than this node.
	 * 
	 * @param node The node to consider.
	 * @return If the given node is a parent within the tree this node belongs
	 *         to.
	 */
	public boolean contains(Node<T> node) {
		Node<T> current = this;
		int count = 0;
		while(current.getParent() != null) {
			count++;
			current = current.getParent();
		}
		Node<T> n = containsRecurse(current, node);
		if(n == null)
			return false;
		while(n.getParent() != null) {
			count--;
			n = n.getParent();
		}
		return count >= -1;
	}

    /**
     * Determines if the given node is a parent in the subtree this node belongs
     *            to.
     * 
     * @param root The root node of this subtree.
     * @param node The node to consider.
     * @return If the given node is a parent within the tree this node belongs
     *         to.
     */
	public Node<T> containsRecurse(Node<T> root, Node<T> node) {
		if(root.children.isEmpty() && !root.equals(node))
			return null;
		if(root.equals(node))
			return root;
		for(Node<T> n : root.getChildren()){
			Node<T> no = containsRecurse(n, node);
			if(no != null)
				return no;
		}	
		return null;
	}

	/* (non-Javadoc)
	 * @see java.lang.Object#toString()
	 */
	public String toString() {
		return data.toString() + (children.isEmpty() ? "" :
		    children.toString());
	}

}
